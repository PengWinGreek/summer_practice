[
  {
    "problem": "Что из себя представляет тип данных string в языке Golang? Можно ли изменить определенный символ в строке? Что происходит при склеивании строк?",
    "code_snippet": "" 
  },
  {
    "problem": "Как эффективно склеивать множество строк?",
    "code_snippet": ""
  },
  {
    "problem": "Что будет происходить при конкурентной записи в map? Как можно решить эту проблему?",
    "code_snippet": ""
  },
  {
    "problem": "Расскажите о ООП в Golang.",
    "code_snippet": ""
  },
  {
    "problem": "Какое будет значение у переменной x после выполнения программы?",
    "code_snippet": ""
  },
  {
    "problem": "Какое значение примет выражение?",
    "code_snippet": "fmt.Println((true && false) || (false && true) || !(false && false))"
  },
  {
    "problem": "Мы знаем, что в десятичной системе самое большое число из одной цифры - это 9, а из двух - 99. В бинарной системе самое большое число из двух цифр это 11 (3), самое большое число из трех цифр это 111 (7) и самое большое число из 4 цифр это 1111 (15). Вопрос: каково самое большое число из 8 цифр? (Подсказка: 101-1=9 и 102-1=99)",
    "code_snippet": ""
  },
  {
    "problem": "Что выведет следующая программа?",
    "code_snippet": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ti := 65\n\tfmt.Println(string(i))\n}"
  },
  {
    "problem": "Что выведет следующая программа?",
    "code_snippet": "package main\n\nimport \"fmt\"\n\nfunc main() {\n\ta := [5]int{1, 2, 3, 4, 5}\n\tt := a[3:4:4]\n\tfmt.Println(t[0])\n}"
  },
  {
    "problem": "Как работает Garbage Collection в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое interface, как они работают в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое slice, как устроены и чем отличаются от массивов?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое len и capacity в slice Go?",
    "code_snippet": ""
  },
  {
    "problem": "Возможно ли предугадать, что GC отработает за константное время N?",
    "code_snippet": ""
  },
  {
    "problem": "Что будет, если создать канал и отправить туда запись, но у него нет читателей?",
    "code_snippet": ""
  },
  {
    "problem": "По какому алгоритму растет slice? (если знаете старую и новую формулу - круто)",
    "code_snippet": ""
  },
  {
    "problem": "Сколько весят такие структуры данных, как слайс, мапа, пустая строка, число в байтах?",
    "code_snippet": ""
  },
  {
    "problem": "В какой момент инициализированное значение переменной передается в defer? Как это связано с именованием функции?",
    "code_snippet": ""
  },
  {
    "problem": "Go — императивный или декларативный? А в чем разница?",
    "code_snippet": ""
  },
  {    "problem": "Что такое type switch?",
    "code_snippet": ""
  },
  {
    "problem": "Как сообщить компилятору, что наш тип реализует интерфейс?",
    "code_snippet": ""
  },
  {
    "problem": "Как работает append?",
    "code_snippet": ""
  },
  {
    "problem": "Какое у slice zero value? Какие операции над ним возможны?",
    "code_snippet": ""
  },
  {
    "problem": "Как устроен тип map?",
    "code_snippet": ""
  },
  {
    "problem": "Каков порядок перебора map?",
    "code_snippet": ""
  },
  {
    "problem": "Что будет, если читать из закрытого канала?",
    "code_snippet": ""
  },
  {
    "problem": "Что будет, если писать в закрытый канал?",
    "code_snippet": ""
  },
  {
    "problem": "Как вы отсортируете массив структур по алфавиту по полю Name?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое сериализация? Зачем она нужна?",
    "code_snippet": ""
  },
  {
    "problem": "Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?",
    "code_snippet": ""
  },
  {
    "problem": "Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?",
    "code_snippet": ""
  },
  {
    "problem": "Предположим, ваша функция должна возвращать детализированные Recoverable и Fatal ошибки. Как это реализовано в пакете net? Как это надо делать в современном Go?",
    "code_snippet": ""
  },
  {
    "problem": "Главный недостаток стандартного логгера?",
    "code_snippet": ""
  },
  {
    "problem": "Есть ли для Go хороший orm? Ответ обоснуйте.",
    "code_snippet": ""
  },
  {
    "problem": "Какой у вас любимый линтер?",
    "code_snippet": ""
  },
  {
    "problem": "Можно ли использовать один и тот же буфер []byte в нескольких горутинах?",
    "code_snippet": ""
  },
  {
    "problem": "Какие типы мьютексов предоставляет stdlib?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое lock-free структуры данных, и есть ли в Go такие?",
    "code_snippet": ""
  },
  {
    "problem": "Способы поиска проблем производительности на проде?",
    "code_snippet": ""
  },
  {
    "problem": "Стандартный набор метрик prometheus в Go -программе?",
    "code_snippet": ""
  },
  {
    "problem": "Как встроить стандартный профайлер в свое приложение?",
    "code_snippet": ""
  },
  {
    "problem": "Overhead от стандартного профайлера?",
    "code_snippet": ""
  },
  {
    "problem": "Почему встраивание — не наследование?",
    "code_snippet": ""
  },
  {
    "problem": "Какие средства обобщенного программирования есть в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Какие технологические преимущества языка Go вы можете назвать?",
    "code_snippet": ""
  },
  {
    "problem": "Какие технологические недостатки языка Go вы можете назвать?",
    "code_snippet": ""
  },
  {
    "problem": "Напишите программу, которая меняет местами два числа",
    "code_snippet": ""
  },
  {
    "problem": "Что такое буферизированный канал? Как создать такой канал с ёмкостью в 20 сообщений?",
    "code_snippet": ""
  },
  {
    "problem": "Напишите собственную функцию Sleep, используя time.After",
    "code_snippet": ""
  },
  {
    "problem": "Как задать направление канала?",
    "code_snippet": ""
  },
  {
    "problem": "На вход подаются два неупорядоченных слайса любой длины. Надо написать функцию, которая возвращает их пересечение",
    "code_snippet": ""
  },
  {
    "problem": "Написать генератор случайных чисел",
    "code_snippet": ""
  },
  {
    "problem": "Слить N каналов в один\nДаны n каналов типа chan int. Надо написать функцию, которая смерджит все данные из этих каналов в один и вернет его.",
    "code_snippet": ""
  },
  {
    "problem": "Сделать конвейер чисел\nДаны два канала. В первый пишутся числа. Нужно, чтобы числа читались из первого по мере поступления, что-то с ними происходило (допустим, возводились в квадрат) и результат записывался во второй канал.",
    "code_snippet": ""
  },
  {
    "problem": "Написать WorkerPool с заданной функцией",
    "code_snippet": ""
  },
  {
    "problem": "Сделать кастомную waitGroup на семафоре",
    "code_snippet": ""
  },
  {
    "problem": "Что выведет код?",
    "code_snippet": "package main\n\nimport (\n  \"fmt\"\n  \"runtime\"\n)\n\nfunc main() {\n   runtime.GOMAXPROCS(1)\n\n   done := false\n\n   go func() {\n      done = true\n   }()\n\n   for !done {\n   }\n   fmt.Println(\"finished\")\n}"
  },
  {
    "problem": "Какая есть проблема в коде?",
    "code_snippet": "var counter int\nfor i := 0; i < 1000; i++ {\n   go func() {\n      counter++\n   }()\n}"
  },
  {
    "problem": "Что выведет код?",
    "code_snippet": "func main() {\n   v := 5\n   p := &v\n   println(*p)\n\n   changePointer(p)\n   println(*p)\n}\n\nfunc changePointer(p *int) {\n   v := 3\n   p = &v\n}"
  },
  {
    "problem": "Что выведет код?",
    "code_snippet": "func worker() chan int {\n   ch := make(chan int)\n\n   go func() {\n      time.Sleep(3 * time.Second)\n      ch <- 42\n   }()\n\n   return ch\n}\n\nfunc main() {\n   timeStart := time.Now()\n\n   _, _ = <-worker(), <-worker()\n\n   println(int(time.Since(timeStart).Seconds())) // что выведет - 3 или 6?\n}"
  },
  {
    "problem": "Что такое Go и почему он был создан?",
    "code_snippet": ""
  },
  {
    "problem": "Объясните архитектуру рабочего пространства в Go.",
    "code_snippet": ""
  },
  {
    "problem": "Как используется переменная окружения GOPATH?",
    "code_snippet": ""
  },
  {
    "problem": "Каковы ключевые особенности Go по сравнению с другими языками программирования?",
    "code_snippet": ""
  },
  {
    "problem": "Опишите, как структурированы пакеты в программе на Go.",
    "code_snippet": ""
  },
  {
    "problem": "Что такое срезы в Go и чем они отличаются от массивов?",
    "code_snippet": ""
  },
  {
    "problem": "Можете ли вы объяснить, что такое горутина?",
    "code_snippet": ""
  },
  {
    "problem": "Как Go управляет памятью?",
    "code_snippet": ""
  },
  {
    "problem": "Можете ли вы перечислить и объяснить основные типы данных в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое нулевое значение переменной в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Как управлять обработкой ошибок в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Можно ли преобразовывать между разными типами данных в Go? Как?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое канал в Go и когда его следует использовать?",
    "code_snippet": ""
  },
  {
    "problem": "Объясните конкурентность в Go и как она сравнивается с параллелизмом.",
    "code_snippet": ""
  },
  {
    "problem": "Что делает ключевое слово range?",
    "code_snippet": ""
  },
  {
    "problem": "В чем разница между горутинами и потоками операционной системы?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое пустой интерфейс (interface{}) в Go и в каких случаях он полезен?",
    "code_snippet": ""
  },
  {
    "problem": "Как реализовать собственный примитив для управления памятью в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Как работает Garbage Collector в Golang?",
    "code_snippet": ""
  },
  {
    "problem": "В какой момент runtime решает запустить сборщик мусора?",
    "code_snippet": ""
  },
  {
    "problem": "Какие недостатки у подхода Mark-and-Sweep?",
    "code_snippet": ""
  },
  {
    "problem": "Как интегрировать pprof в приложение для профилирования CPU и памяти?",
    "code_snippet": ""
  },
  {
    "problem": "Для чего нужны параметры GOGC и GODEBUG?",
    "code_snippet": ""
  },
  {
    "problem": "Что такое middleware и router в Go?",
    "code_snippet": ""
  },
  {
    "problem": "Каковы значения len и cap после выполнения?",
    "code_snippet": "a := [5]int{1, 2, 3, 4, 5}\ns := a[1:4]"
  },
  {
    "problem": "Как изменятся значения base при модификации его подмножества?",
    "code_snippet": "base := []int{10, 20, 30, 40}\nnewSlice := base[1:3]\nnewSlice[1] = 50"
  },
  {
    "problem": "Как изменятся len и cap после выполнения кода?",
    "code_snippet": "original := make([]int, 3, 5)\noriginal = append(original, 1, 2, 3)"

  },
  {
    "problem": "В чем разница между nilSlice и emptySlice и что вернёт следующая проверка: nilSlice == nil и emptySlice == nil?",
    "code_snippet": "var nilSlice []int\nemptySlice := make([]int, 0)"
  },
  {
    "problem": "Каким будет значение slices после выполнения кода?",
    "code_snippet": "slices := [][]int{\n  {1, 2},\n  {3, 4},\n}\nslices[0] = append(slices[0], 3)"
  },
  {
    "problem": "Почему, когда вы добавляете элемент в слайс с помощью append, иногда вам может понадобиться новый участок памяти, и иногда — нет? Как это связано с емкостью (capacity) слайса?",
    "code_snippet": ""
  },
  {
    "problem": "Nil vs Empty slice: Какова разница между nil слайсом и пустым слайсом? В каких случаях один из них предпочтительнее другого?",
    "code_snippet": ""
  },
  {
    "problem": "Как бы вы удалили элемент из слайса без использования стандартной библиотеки, не нарушив порядок следования элементов?",
    "code_snippet": ""
  },
  {
    "problem": "Можно ли утверждать, что после обрезания большого слайса до меньшего (например, largeSlice = largeSlice[:5]) память, занимаемая оставшимися элементами, будет освобождена? Если нет, почему и как это может привести к утечке памяти?",
    "code_snippet": ""
  },
  {
    "problem": "Что выведет этот код?",
    "code_snippet": "taskList := []string{\n    \"Проснуться\",\n    \"Покушать\",\n    \"Поработать\",\n}\n\nwakeup := taskList[0:2]\nwork := taskList[2:3]\n\nwakeup = append(wakeup, \"Погулять с собакой\")\n\nfmt.Println(\"Wakeup staff: \", wakeup)\nfmt.Println(\"Workstaff:\", work)"
  },
  {
    "problem": "Семантика нулевых мап. Что произойдет при выполнении следующего кода?",
    "code_snippet": ""
  },
  {
    "problem": "Ссылочная природа мап. Какой будет результат на выходе и почему?",
    "code_snippet": "func modifyMap(m map[int]string) {\n    m[2] = \"changed\"\n}\n\nfunc main() {\n    myMap := map[int]string{1: \"one\", 2: \"two\", 3: \"three\"}\n    modifyMap(myMap)\n    fmt.Println(myMap)\n}"
  },
  {
    "problem": "Удаление из мапы во время итерации. Является ли следующий код безопасным, и если нет, почему?",
    "code_snippet": "m := map[int]bool{1: true, 2: true, 3: true}\nfor k := range m {\n    if k == 2 {\n        delete(m, k)\n    }\n}"
  },
  {
    "problem": "Как определить отсутствие ключа в map?",
    "code_snippet": ""
  },
  {
    "problem": "В каком порядке ключи возвращаются при итерации по мапе с помощью цикла range? Гарантирован ли этот порядок?",
    "code_snippet": ""
  },
  {    
    "problem": "Что выведет следующий код?",
    "code_snippet": "func setLinkHome(link *string) {\n    *link = \"http://home\"\n}\n\nlink := \"http://other\"\nsetLinkHome(&link)\nfmt.Println(link)"
  },
  {
    "problem": "Что содержится в i?",
    "code_snippet": "var ptr *int\ni := 10\nptr = &i\n*ptr++"
  },
  {
    "problem": "В чем разница между указателем на массив и указателем на слайс?",
    "code_snippet": ""
  },
  {
    "problem": "Функции с передачей по указателю. Что будет выведено на экран? Почему было решено использовать передачу по указателю в этом примере?",
    "code_snippet": "func modifyValue(x *int) {\n    *x = 5\n}\n\nfunc main() {\n    var num int = 2\n    modifyValue(&num)\n    fmt.Println(num)\n}"
  },
  {
    "problem": "Как Go управляет указателями при сборке мусора? Что может случиться, если у вас есть указатель на большой кусок памяти,на который никто не ссылается?",
    "code_snippet": ""
  },
  {
    "problem": "В приведенном коде есть двойное разыменование. Можете ли вы объяснить, что это такое и почему это работает?",
    "code_snippet": "type Node struct {\n    value int\n    next  *Node\n}\n\nfirst := &Node{value: 1}\nsecond := &Node{value: 2}\nfirst.next = second\n\nfmt.Println(first.next.value)"
  },
  {
    "problem": "Будет ли напечатан ok?",
    "code_snippet": "func main() {\n    defer func() {\n        recover()\n    }()\n    panic(\"test panic\")\n    fmt.Println(\"ok\")\n}"
  },
  {
    "problem": "Исправь код, функция должна выводить: one\ntwo\three\n(в любом порядке)\nDone!",
    "code_snippet": "func printText(data []string) {\n    wg := sync.WaitGroup{}\n    for _, v := range data {\n        go func(v string ) {\n            wg.Add(1)\n            fmt.Println(v)\n            wg.Done()\n        }(v)\n    }\n    fmt.Println(\"done!\")\n}\n\ndata := []string{\"one\", \"two\", \"three\"}\nprintText(data)"
  },
  {
    "problem": "Мы пытаемся подсчитать количество выполненных параллельно операций, что может пойти не так?",
    "code_snippet": "var callCounter uint\n\nfunc main() {\n    for i := 0; i < 10000; i++ {\n        go func() {\n            // Ходим в базу, делаем долгую работу\n            time.Sleep(time.Second)\n            // Увеличиваем счетчик\n            callCounter++\n        }()\n    }\n    fmt.Println(\"Call counter value = \", callCounter)\n}"
  },
  {
    "problem": "Есть функция processDataInternal, которая может выполняться неопределенно долго. Чтобы контролировать процесс, мы добавили таймаут выполнения ф-ии через context. Какие недостатки кода ниже?",
    "code_snippet": "func (s *Service) ProcessData(timeoutCtx context.Context, r io.Reader) error {\n  errCh := make(chan error)\n\n  go func() {\n    errCh <- s.processDataInternal(r)\n  }()\n\n\n  select {\n  case err := <-errCh:\n    return err\n  case <-timeoutCtx.Done():\n    return timeoutCtx.Err()\n  }\n}"
  },
  {
    "problem": "Что выведет программа?",
    "code_snippet": "func a() {\n    x := []int{}\n    x = append(x, 0)\n    x = append(x, 1)\n    x = append(x, 2)\n    y := append(x, 3)\n    z := append(x, 4)\n    fmt.Println(y, z)\n}\n\nfunc main() {\n    a()\n}"
  },
  {
    "problem": "Что выведет этот код?",
    "code_snippet": "s := \"test\"\nprintln(s[0]) // 116 (код ASCII для 't')\n\n// Невозможно изменить символ в строке напрямую. Строки в Go неизменяемы.\n// s[0] = \"R\"  // Это вызовет ошибку компиляции\n\nvar newS string = \"R\"\ncounter := 0\nfor _, item := range s {\n    counter++\n    if counter == 1 {\n        continue\n    }\n    newS = strings.Join([]string{newS, string(item)}, \"\")\n}\nprintln(newS) // Rest"
  },
  {
    "problem": "Как оптимизировать медленный SQL-запрос?",
    "code_snippet": ""
  },
  {
    "problem": "Блокируется ли этот код, или нет?",
    "code_snippet": "ch := make(chan int)\ngo func() {\n    <-ch\n}()\nch <- 1"
  },
  {
    "problem": "Что произойдет после выполнения этого кода?",
    "code_snippet": "ch := make(chan int)\nclose(ch)\nch <- 1"
  },
  {
    "problem": "Что содержится в переменной val после выполнения этого кода?",
    "code_snippet": "ch1 := make(chan chan int)\nch2 := make(chan int)\ngo func() {\n    ch2 <- 1\n}()\nch1 <- ch2\nval := <-<-ch1"
  },
  {
    "problem": "Как вы можете узнать, закрыт ли канал, если при попытке чтения из закрытого канала возвращается нулевое значение?",
    "code_snippet": ""
  },
  {
    "problem": "Есть ли стандартный способ узнать, сколько элементов в настоящий момент находится в канале? Если нет, как бы вы обошли это ограничение?",
    "code_snippet": ""
  },
  {
    "problem": "Каким образом следующий код будет синхронизирован, чтобы избежать состояние гонки? Какие другие методы синхронизации горутин вы знаете?",
    "code_snippet": "counter := 0\nvar mu sync.Mutex\n\ngo func() {\n    mu.Lock()\n    counter++\n    mu.Unlock()\n}()\n\ngo func() {\n    mu.Lock()\n    counter++\n    mu.Unlock()\n}()"
  },
  {
    "problem": "Что произойдет при выполнении следующего кода и почему? Как бы вы решили проблему в этом коде?",
    "code_snippet": "ch := make(chan int)\nch <- 1"
  },
  {
    "problem": "Представьте, что у вас есть два канала ввода и один канал вывода. Как бы вы организовали чтение из обоих каналов ввода и отправку результатов в канал вывода?",
    "code_snippet": ""
  },
  {
    "problem": " Каким образом можно определить, что канал был закрыт, если канал может передавать значения типа int, и значение 0 является допустимым значением в канале?",
    "code_snippet": ""
  },
  {
    "problem": "Предположим, что у вас есть буферизированный канал с вместимостью 3, и вы хотите знать, сколько элементов в нем в данный момент. Как бы вы это сделали?",
    "code_snippet": ""
  },
  {
    "problem": "Как бы вы конкатенировали большое количество строк эффективно, минимизируя накладные расходы связанные с выделением памяти?",
    "code_snippet": ""
  },
  {
    "problem": "Каковы различия между len и utf8.RuneCountInString при работе со строками, и в каких ситуациях вы бы использовали один метод вместо другого?",
    "code_snippet": ""
  },
  {
    "problem": "Как в Go осуществляется сравнение строк, и что нужно учитывать при сравнении строк в разных языках и кодировках?",
    "code_snippet": ""
  },
  {
    "problem": "Расскажите, как вы бы извлекли подстроку из строки в Go. Как бы вы обработали строки, содержащие многобайтовые символы, такие как руны Unicode?",
    "code_snippet": ""
  },
  {
    "problem": "Объясните, как в Go преобразовать строку в число и число в строку, и как обрабатывать возможные ошибки при этих преобразованиях?",
    "code_snippet": ""
  },
  {
    "problem": "Как бы вы обрабатывали и изменяли строки для создания эффективного и безопасного веб-сервера, который может обрабатывать входные данные от пользователя и предотвращать атаки, такие как XSS и SQL инъекции?",
    "code_snippet": ""
  }
]



